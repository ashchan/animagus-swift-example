// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ast.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Ast_Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var t: Ast_Value.TypeEnum = .nil

  var primitive: Ast_Value.OneOf_Primitive? = nil

  var b: Bool {
    get {
      if case .b(let v)? = primitive {return v}
      return false
    }
    set {primitive = .b(newValue)}
  }

  var u: UInt64 {
    get {
      if case .u(let v)? = primitive {return v}
      return 0
    }
    set {primitive = .u(newValue)}
  }

  var raw: Data {
    get {
      if case .raw(let v)? = primitive {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {primitive = .raw(newValue)}
  }

  var children: [Ast_Value] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Primitive: Equatable {
    case b(Bool)
    case u(UInt64)
    case raw(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Ast_Value.OneOf_Primitive, rhs: Ast_Value.OneOf_Primitive) -> Bool {
      switch (lhs, rhs) {
      case (.b(let l), .b(let r)): return l == r
      case (.u(let l), .u(let r)): return l == r
      case (.raw(let l), .raw(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Primitive fields
    case `nil` // = 0
    case uint64 // = 1
    case bool // = 2
    case bytes // = 3
    case error // = 4

    /// In animagus, we distinguish args and params in the following way:
    /// * If a Value struct contains an arg, it will be interpretted as a
    /// function, when used in constructs such as REDUCE or MAP, args acts
    /// as placeholders for the values to test/transform.
    /// * Params, on the other hand, denotes user input when calling RPCs,
    /// for example, a user might provide an amount to transfer, or an address
    /// to transfer to, those will be represented via parameters
    case arg // = 16
    case param // = 17

    /// Blockchain data structures
    case outPoint // = 18
    case cellInput // = 19
    case cellDep // = 20
    case script // = 21
    case cell // = 22
    case transaction // = 23
    case header // = 24

    /// Compound fields
    case apply // = 25
    case reduce // = 26

    /// List fields
    case list // = 27
    case queryCells // = 28
    case map // = 29
    case filter // = 30

    /// Cell get operations
    case getCapacity // = 48
    case getData // = 49
    case getLock // = 50
    case getType // = 51
    case getDataHash // = 52
    case getOutPoint // = 53

    /// Script get operations
    case getCodeHash // = 54
    case getHashType // = 55
    case getArgs // = 56

    /// Transaction get operations
    case getCellDeps // = 57
    case getHeaderDeps // = 58
    case getInputs // = 59
    case getOutputs // = 60
    case getWitnesses // = 61

    /// Header get operations
    case getCompactTarget // = 62
    case getTimestamp // = 63
    case getNumber // = 64
    case getEpoch // = 65
    case getParentHash // = 66
    case getTransactionsRoot // = 67
    case getProposalsHash // = 68
    case getUnclesHash // = 69
    case getDao // = 70
    case getNonce // = 71
    case getHeader // = 72

    /// Operations
    case hash // = 73
    case serializeToCore // = 74
    case serializeToJson // = 75
    case not // = 76
    case and // = 77
    case or // = 78
    case equal // = 80
    case less // = 81
    case len // = 82
    case slice // = 83
    case index // = 84
    case add // = 85
    case subtract // = 86
    case multiply // = 87
    case divide // = 88
    case mod // = 89

    /// Special operations
    case cond // = 120
    case tailRecursion // = 121
    case UNRECOGNIZED(Int)

    init() {
      self = .nil
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nil
      case 1: self = .uint64
      case 2: self = .bool
      case 3: self = .bytes
      case 4: self = .error
      case 16: self = .arg
      case 17: self = .param
      case 18: self = .outPoint
      case 19: self = .cellInput
      case 20: self = .cellDep
      case 21: self = .script
      case 22: self = .cell
      case 23: self = .transaction
      case 24: self = .header
      case 25: self = .apply
      case 26: self = .reduce
      case 27: self = .list
      case 28: self = .queryCells
      case 29: self = .map
      case 30: self = .filter
      case 48: self = .getCapacity
      case 49: self = .getData
      case 50: self = .getLock
      case 51: self = .getType
      case 52: self = .getDataHash
      case 53: self = .getOutPoint
      case 54: self = .getCodeHash
      case 55: self = .getHashType
      case 56: self = .getArgs
      case 57: self = .getCellDeps
      case 58: self = .getHeaderDeps
      case 59: self = .getInputs
      case 60: self = .getOutputs
      case 61: self = .getWitnesses
      case 62: self = .getCompactTarget
      case 63: self = .getTimestamp
      case 64: self = .getNumber
      case 65: self = .getEpoch
      case 66: self = .getParentHash
      case 67: self = .getTransactionsRoot
      case 68: self = .getProposalsHash
      case 69: self = .getUnclesHash
      case 70: self = .getDao
      case 71: self = .getNonce
      case 72: self = .getHeader
      case 73: self = .hash
      case 74: self = .serializeToCore
      case 75: self = .serializeToJson
      case 76: self = .not
      case 77: self = .and
      case 78: self = .or
      case 80: self = .equal
      case 81: self = .less
      case 82: self = .len
      case 83: self = .slice
      case 84: self = .index
      case 85: self = .add
      case 86: self = .subtract
      case 87: self = .multiply
      case 88: self = .divide
      case 89: self = .mod
      case 120: self = .cond
      case 121: self = .tailRecursion
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .nil: return 0
      case .uint64: return 1
      case .bool: return 2
      case .bytes: return 3
      case .error: return 4
      case .arg: return 16
      case .param: return 17
      case .outPoint: return 18
      case .cellInput: return 19
      case .cellDep: return 20
      case .script: return 21
      case .cell: return 22
      case .transaction: return 23
      case .header: return 24
      case .apply: return 25
      case .reduce: return 26
      case .list: return 27
      case .queryCells: return 28
      case .map: return 29
      case .filter: return 30
      case .getCapacity: return 48
      case .getData: return 49
      case .getLock: return 50
      case .getType: return 51
      case .getDataHash: return 52
      case .getOutPoint: return 53
      case .getCodeHash: return 54
      case .getHashType: return 55
      case .getArgs: return 56
      case .getCellDeps: return 57
      case .getHeaderDeps: return 58
      case .getInputs: return 59
      case .getOutputs: return 60
      case .getWitnesses: return 61
      case .getCompactTarget: return 62
      case .getTimestamp: return 63
      case .getNumber: return 64
      case .getEpoch: return 65
      case .getParentHash: return 66
      case .getTransactionsRoot: return 67
      case .getProposalsHash: return 68
      case .getUnclesHash: return 69
      case .getDao: return 70
      case .getNonce: return 71
      case .getHeader: return 72
      case .hash: return 73
      case .serializeToCore: return 74
      case .serializeToJson: return 75
      case .not: return 76
      case .and: return 77
      case .or: return 78
      case .equal: return 80
      case .less: return 81
      case .len: return 82
      case .slice: return 83
      case .index: return 84
      case .add: return 85
      case .subtract: return 86
      case .multiply: return 87
      case .divide: return 88
      case .mod: return 89
      case .cond: return 120
      case .tailRecursion: return 121
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Ast_Value.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ast_Value.TypeEnum] = [
    .nil,
    .uint64,
    .bool,
    .bytes,
    .error,
    .arg,
    .param,
    .outPoint,
    .cellInput,
    .cellDep,
    .script,
    .cell,
    .transaction,
    .header,
    .apply,
    .reduce,
    .list,
    .queryCells,
    .map,
    .filter,
    .getCapacity,
    .getData,
    .getLock,
    .getType,
    .getDataHash,
    .getOutPoint,
    .getCodeHash,
    .getHashType,
    .getArgs,
    .getCellDeps,
    .getHeaderDeps,
    .getInputs,
    .getOutputs,
    .getWitnesses,
    .getCompactTarget,
    .getTimestamp,
    .getNumber,
    .getEpoch,
    .getParentHash,
    .getTransactionsRoot,
    .getProposalsHash,
    .getUnclesHash,
    .getDao,
    .getNonce,
    .getHeader,
    .hash,
    .serializeToCore,
    .serializeToJson,
    .not,
    .and,
    .or,
    .equal,
    .less,
    .len,
    .slice,
    .index,
    .add,
    .subtract,
    .multiply,
    .divide,
    .mod,
    .cond,
    .tailRecursion,
  ]
}

#endif  // swift(>=4.2)

struct Ast_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var result: Ast_Value {
    get {return _result ?? Ast_Value()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Ast_Value? = nil
}

struct Ast_Stream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var filter: Ast_Value {
    get {return _filter ?? Ast_Value()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  mutating func clearFilter() {self._filter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filter: Ast_Value? = nil
}

struct Ast_Root {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var calls: [Ast_Call] = []

  var streams: [Ast_Stream] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ast"

extension Ast_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "t"),
    2: .same(proto: "b"),
    3: .same(proto: "u"),
    4: .same(proto: "raw"),
    8: .same(proto: "children"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.t)
      case 2:
        if self.primitive != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.primitive = .b(v)}
      case 3:
        if self.primitive != nil {try decoder.handleConflictingOneOf()}
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {self.primitive = .u(v)}
      case 4:
        if self.primitive != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.primitive = .raw(v)}
      case 8: try decoder.decodeRepeatedMessageField(value: &self.children)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.t != .nil {
      try visitor.visitSingularEnumField(value: self.t, fieldNumber: 1)
    }
    switch self.primitive {
    case .b(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    case .u(let v)?:
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    case .raw(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    case nil: break
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ast_Value, rhs: Ast_Value) -> Bool {
    if lhs.t != rhs.t {return false}
    if lhs.primitive != rhs.primitive {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ast_Value.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NIL"),
    1: .same(proto: "UINT64"),
    2: .same(proto: "BOOL"),
    3: .same(proto: "BYTES"),
    4: .same(proto: "ERROR"),
    16: .same(proto: "ARG"),
    17: .same(proto: "PARAM"),
    18: .same(proto: "OUT_POINT"),
    19: .same(proto: "CELL_INPUT"),
    20: .same(proto: "CELL_DEP"),
    21: .same(proto: "SCRIPT"),
    22: .same(proto: "CELL"),
    23: .same(proto: "TRANSACTION"),
    24: .same(proto: "HEADER"),
    25: .same(proto: "APPLY"),
    26: .same(proto: "REDUCE"),
    27: .same(proto: "LIST"),
    28: .same(proto: "QUERY_CELLS"),
    29: .same(proto: "MAP"),
    30: .same(proto: "FILTER"),
    48: .same(proto: "GET_CAPACITY"),
    49: .same(proto: "GET_DATA"),
    50: .same(proto: "GET_LOCK"),
    51: .same(proto: "GET_TYPE"),
    52: .same(proto: "GET_DATA_HASH"),
    53: .same(proto: "GET_OUT_POINT"),
    54: .same(proto: "GET_CODE_HASH"),
    55: .same(proto: "GET_HASH_TYPE"),
    56: .same(proto: "GET_ARGS"),
    57: .same(proto: "GET_CELL_DEPS"),
    58: .same(proto: "GET_HEADER_DEPS"),
    59: .same(proto: "GET_INPUTS"),
    60: .same(proto: "GET_OUTPUTS"),
    61: .same(proto: "GET_WITNESSES"),
    62: .same(proto: "GET_COMPACT_TARGET"),
    63: .same(proto: "GET_TIMESTAMP"),
    64: .same(proto: "GET_NUMBER"),
    65: .same(proto: "GET_EPOCH"),
    66: .same(proto: "GET_PARENT_HASH"),
    67: .same(proto: "GET_TRANSACTIONS_ROOT"),
    68: .same(proto: "GET_PROPOSALS_HASH"),
    69: .same(proto: "GET_UNCLES_HASH"),
    70: .same(proto: "GET_DAO"),
    71: .same(proto: "GET_NONCE"),
    72: .same(proto: "GET_HEADER"),
    73: .same(proto: "HASH"),
    74: .same(proto: "SERIALIZE_TO_CORE"),
    75: .same(proto: "SERIALIZE_TO_JSON"),
    76: .same(proto: "NOT"),
    77: .same(proto: "AND"),
    78: .same(proto: "OR"),
    80: .same(proto: "EQUAL"),
    81: .same(proto: "LESS"),
    82: .same(proto: "LEN"),
    83: .same(proto: "SLICE"),
    84: .same(proto: "INDEX"),
    85: .same(proto: "ADD"),
    86: .same(proto: "SUBTRACT"),
    87: .same(proto: "MULTIPLY"),
    88: .same(proto: "DIVIDE"),
    89: .same(proto: "MOD"),
    120: .same(proto: "COND"),
    121: .same(proto: "TAIL_RECURSION"),
  ]
}

extension Ast_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularMessageField(value: &self._result)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ast_Call, rhs: Ast_Call) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ast_Stream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Stream"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "filter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._filter)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ast_Stream, rhs: Ast_Stream) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ast_Root: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Root"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "calls"),
    2: .same(proto: "streams"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.calls)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.streams)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.calls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calls, fieldNumber: 1)
    }
    if !self.streams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.streams, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ast_Root, rhs: Ast_Root) -> Bool {
    if lhs.calls != rhs.calls {return false}
    if lhs.streams != rhs.streams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
